/*------------------------------------------------------------
(C) Copyright [2006-2008] Marvell International Ltd.
All Rights Reserved
------------------------------------------------------------*/

/*================================================================================================
File        : osa_mem.c
Description : Implementation of OSA dynamic memory handling - OS independent.
Copyright (c) 2008 Marvell All Rights Reserved
---------------------------------------------------------------------*/

/*
 * Include File
 */
#include <stdio.h>
#include <stddef.h>
#include <string.h>

#include "osa.h"
#include "osa_internals.h"
#include "osa_mem.h"

#include "diag.h"


/*
 * Constants
 */

#define     MIN_BUF_MASK                    (SIZEOF_MIN_BUF-1)
#define     BUF_SIZE(rEQsIZE)               ((rEQsIZE + MIN_BUF_MASK) & ~MIN_BUF_MASK)
#define     FREE_LIST_INDEX(sIZE)           ((sIZE <= LARGEST_BUF_WITH_SPECIAL_LIST) ? ((sIZE - 1) / SIZEOF_MIN_BUF) : (NUMBER_OF_FREE_LISTS - 1))
#define     POOL_ID                         0x48287997          //  This is used for the ICAT EXPORTED FUNCTIONs



#define     BUF_DHR_ADRS(PmEM)              ((OsaMem_BufHdr *)((UINT32)(PmEM) - SIZEOF_HDR_OF_ALLOC_BUF))

//#if (SIZEOF_HDR_OF_ALLOC_BUF-SIZEOF_CACHE_LINE)
//#error "BUF_HDR_GUARD Has a wrong value"
//#endif

#define     POOL_HEADER_SIZE                (sizeof(OsaMem_PoolHeader))

typedef enum
{
    eNO_VALIDITY_CHK,
    eMIN_VALIDITY_CHK,
    eEXT_VALIDITY_CHK
} OsaMem_ValiditiyChkE ;

/*
 * Static Functions
 */
static void OsaMemAddToFreeList( OsaMem_BufHdr * ) ;
static void OsaMemDeleteFromFreeList( OsaMem_BufHdr * ) ;
static BOOL OsaMemValidPtr( UINT32, BOOL ) ;
static UINT32 OsaMem_CheckPool( OsaMem_PoolHeader *pPool ) ;

/*
 * Static Data
 */
static OsaRefT
    OsaMem_DefaultPoolRef = NULL ;

static OsaRefT
    OsaMem_CriticalSectionHandle = 0 ;

static OsaMem_PoolHeader
    *OsaMem_FirstPool = NULL ;

static OsaMem_ValiditiyChkE
    OsaMem_ValidityCheck = eNO_VALIDITY_CHK ;

OsaMem_PoolHeader
    *OsaMem_FirstPool_Debug=NULL ;
/*
 * Macros
 */
#define     KB(bYTES)                       ((((bYTES) >> 9) + 1) >> 1)

#define     VALID_PTR(PmEM)             (OsaMem_ValidityCheck ? OsaMemValidPtr((UINT32)(PmEM),FALSE) : TRUE)

#if 1   //  Faster.
#define     SET_GUARD_IN_BUF_HDR(PbUFhDR)       (PbUFhDR)->Guard = GUARD_PATTERN ;
#else
#define     SET_GUARD_IN_BUF_HDR(PbUFhDR)                   \
    {                                                       \
        UINT32 i = BUF_HDR_GUARD - 1 ;                      \
        do (PbUFhDR)->Guard[i] = GUARD_PATTERN ;            \
        while( i-- ) ;                                      \
    }
#endif

#if 0 // (defined FLAVOR_COM)
#define     CHECK_POOL(PpPOOL)                                  \
/*if ( PpPOOL == OsaMem_FirstPool )*/                               \
{                                                               \
    OsaMem_ValiditiyChkE ValidityCheck = OsaMem_ValidityCheck ; \
    OsaMem_ValidityCheck = eNO_VALIDITY_CHK ;                   \
    OsaMem_CheckPool(PpPOOL) ;                                  \
    OsaMem_ValidityCheck = ValidityCheck ;                      \
}
#else
#define     CHECK_POOL(PpPOOL)
#endif


extern 	int uart_printf(const char* fmt, ...);

/***********************************************************************
 *
 * Name:        OsaMemAddMemoryToPool()
 *
 * Description: Add memory to an OSA pool.
 *
 * Parameters:
 *  OsaRefT     poolRef     - memory pool reference
 *  UINT8       *memBase    - starting address of memory for the pool
 *  UINT32      memSize     - total # bytes for the memory pool
 *
 * Returns:
 *  OS_SUCCESS          - service was completed successfully
 *  OS_INVALID_REF      - invalid pool ref.
 *  OS_INVALID_SIZE     - size not large enough.
 *  OS_INVALID_MEMORY   - illegal memory block.
 *
 * Notes:
 *
 ***********************************************************************/
OSA_STATUS OsaMemAddMemoryToPool( OsaRefT poolRef, void *memBase, UINT32 memSize, void *pForFutureUse )
{
    OsaRefT
        Handle ;

    OsaMem_BufHdr
        *pBufHdr ;

    OsaMem_MemBlkHdr
        *pMemBlk ;

    OsaMem_PoolHeader
        *pPool ;

    UINT32
        FirstAdrs,
        LastAdrs,
        OrigMemSize = memSize ;

/*
 * Check Parameters
 */
    FirstAdrs = (UINT32)memBase ;                   //  Temp.
    memBase = (void *)((FirstAdrs + 3) & ~3) ;      //  Align 4.
    memSize -= ((UINT32)memBase - FirstAdrs) ;

    if ( memSize < (sizeof(OsaMem_MemBlkHdr) + SIZEOF_CACHE_LINE + 2*SIZEOF_HDR_OF_ALLOC_BUF + SIZEOF_MIN_BUF) )
        return OS_INVALID_SIZE ;

/*
 * Get poolRef
 */
    if ( ! poolRef )
    {
        poolRef = OsaMem_DefaultPoolRef ;

        if ( ! poolRef )
        {
            OSA_ASSERT( FALSE ) ;
            return OS_INVALID_REF ;
        }
    }

    pPool = (OsaMem_PoolHeader *)poolRef ;

/*
 * Calculate the first memory for allocation
 */
    FirstAdrs = (UINT32)memBase + sizeof(OsaMem_MemBlkHdr) ;
    memSize -= sizeof(OsaMem_MemBlkHdr) ;

    if ( FirstAdrs & CACHE_LINE_MASK )
    {
        UINT32
            mb = FirstAdrs ;

        FirstAdrs = (FirstAdrs + CACHE_LINE_MASK) & ~CACHE_LINE_MASK ;
        memSize -= FirstAdrs - mb ;
    }

    memSize &= ~CACHE_LINE_MASK ;
    LastAdrs = FirstAdrs + memSize - 1 ;

/*
 * Make sure memory is not already in use
 */
    for( pMemBlk=pPool->pFirstMemBlk ; pMemBlk ; pMemBlk=pMemBlk->pNextMemBlk )
        if ( (FirstAdrs >= pMemBlk->FirstAddress  &&  FirstAdrs <= pMemBlk->LastAddress)  ||
             ( LastAdrs >= pMemBlk->FirstAddress  &&   LastAdrs <= pMemBlk->LastAddress) )
        {
//            OSA_ASSERT( FALSE ) ;
//            return OS_INVALID_MEMORY ;
            return OS_SUCCESS ;     //  This is legal because no support for MemPoolDelete .
        }

    pMemBlk = (OsaMem_MemBlkHdr *)memBase ;

    pMemBlk->FirstAddress = FirstAdrs ;
    pMemBlk->LastAddress = LastAdrs ;


/*
 * Set a Dummy buffer at the end of the memory
 */
    memSize -= SIZEOF_HDR_OF_ALLOC_BUF ;

    pBufHdr = (OsaMem_BufHdr *)(FirstAdrs + memSize) ;
    memset( pBufHdr, 0 , SIZEOF_HDR_OF_ALLOC_BUF ) ;

    SET_GUARD_IN_BUF_HDR(pBufHdr) ;
    pBufHdr->poolRef = poolRef ;
    pBufHdr->pPrevBuf = (OsaMem_BufHdr *)FirstAdrs ;
    pBufHdr->AllocCount = 1 ;           //  Make sure we will not free it.

/*
 * Set the Buf Header
 */
    pBufHdr = pBufHdr->pPrevBuf ;
    memset( pBufHdr, 0 , sizeof(OsaMem_BufHdr) ) ;

    SET_GUARD_IN_BUF_HDR(pBufHdr) ;
    pBufHdr->poolRef = poolRef ;
    memSize -= SIZEOF_HDR_OF_ALLOC_BUF ;
    pBufHdr->BufSize = memSize ;

/*
 * Add Buf to Free List
 */
    Handle = OsaCriticalSectionEnter( pPool->CriticalSectionHandle, NULL ) ;

    pMemBlk->pNextMemBlk = pPool->pFirstMemBlk ;
    pPool->pFirstMemBlk = pMemBlk ;

    OsaMemAddToFreeList( pBufHdr ) ;

    pPool->poolSize += OrigMemSize ;
    if ( pPool->MaxBytesInUse  <  (pPool->BytesInUse += (OrigMemSize - memSize)) )
        pPool->MaxBytesInUse = pPool->BytesInUse ;

    OsaCriticalSectionExit( Handle, NULL ) ;

    return OS_SUCCESS ;
}

/***********************************************************************
 *
 * Name:        OsaMemAddToFreeList()
 *
 * Description: Add a free buffer to an OSA pool.
 *
 * Parameters:
 *  OsaMem_BufHdr   *pFreeBuf   - starting address of the memory to add to free list
 *
 *
 * Notes:   This function should be called inside a critical section.
 *
 ***********************************************************************/
static void OsaMemAddToFreeList( OsaMem_BufHdr *pFreeBuf )
{
    OsaMem_PoolHeader
        *pPoolHeader = (OsaMem_PoolHeader *)pFreeBuf->poolRef ;

    UINT32
        FreeListIndex = FREE_LIST_INDEX(pFreeBuf->BufSize) ;

    OsaMem_FreeList
        *pFreeList = &pPoolHeader->FreeList[FreeListIndex] ;

    OsaMem_BufHdr
        *pFree = pFreeList->pFirstBuf,
        *pPrev ;

/*
 * Case when first on list
 */
    if ( ! pFree  ||  pFreeBuf->BufSize <= pFree->BufSize )
    {
        pFreeList->pFirstBuf = pFreeBuf ;
        pFreeBuf->pNextFreeBuf = pFree ;

/*
 * If list was empty - set pointers of the smaller lists
 */
        if ( ! pFree  &&  pFreeList != LAST_FREE_LIST(pPoolHeader) )
            while( FreeListIndex-- )
                if ( pPoolHeader->FreeList[FreeListIndex].pNextList <= pFreeList )
                    break ;
                else
                    pPoolHeader->FreeList[FreeListIndex].pNextList = pFreeList ;

    }

/*
 * Not first - add it to list according to it's size
 */
    else
    {
        do
        {
            pPrev = pFree ;
            pFree = pFree->pNextFreeBuf ;
        }
        while( pFree  &&  pFree->BufSize < pFreeBuf->BufSize ) ;

        pPrev->pNextFreeBuf = pFreeBuf ;
        pFreeBuf->pNextFreeBuf = pFree ;
    }

    if ( pFreeList->maxFreeBuf < ++pFreeList->nFreeBuf )
        pFreeList->maxFreeBuf = pFreeList->nFreeBuf ;
}

UINT32 mallocStepDebug=0;
UINT32 addr_debug=0;
UINT32 mallocSizeDebug=0;

/***********************************************************************
 *
 * Name:        OsaMemAlloc()
 *
 * Description: Allocate Memory.
 *
 * Parameters:
 *  OsaRefT         poolRef     - memory pool reference
 *  UINT32          Size        - Size of needed memory.
 *
 * Returns:
 *  void * - starting address of a the free memory.
 *
 * Notes:
 *
 ***********************************************************************/
void *OsaMemAlloc( OsaRefT poolRef, UINT32 Size )
{
    OsaMem_PoolHeader
        *pPoolHeader ;

    UINT32
        BufSize,
        BufSizeTail,
        FreeListIndex ;

    OsaMem_FreeList
        *pFreeList ;

    OsaMem_BufHdr
        *pFree,
        *pNewBuf ;

    OsaRefT
        Handle ;

    UINT32
        MaxAllocBuf,
        NumberOfFreeBytes ;

	UINT32 CallerAddress ;

#if defined(__ARMCC_VERSION)
	CallerAddress= (__ARMCC_VERSION >= 200000) ? __return_address() : 0 ;  //  Keep first.
#else
	CallerAddress = 0;
#endif
	mallocStepDebug=1;
	mallocSizeDebug = Size;
/*
 * Check Parameters
 */
 
	if( Size == 0 ){
		OSA_ASSERT( FALSE ) ;
		return FALSE ;
	}

    if ( ! poolRef )
    {
        poolRef = OsaMem_DefaultPoolRef ;

        if ( ! poolRef )
        {
        	mallocStepDebug=11;
            OSA_ASSERT( FALSE ) ;
            return NULL ;
        }
    }

	mallocStepDebug=2;
    if ( OsaMem_ValidityCheck == eEXT_VALIDITY_CHK )
        BufSize = BUF_SIZE(Size + 4) ;     //  Make sure to have at least one guard at the end of the data.
    else
        BufSize = BUF_SIZE(Size) ;

    FreeListIndex = FREE_LIST_INDEX(BufSize) ;

/*
 * Enter Critical Section
 */
    pPoolHeader = (OsaMem_PoolHeader *)poolRef ;
    pFreeList = &pPoolHeader->FreeList[FreeListIndex] ;

    Handle = OsaCriticalSectionEnter( pPoolHeader->CriticalSectionHandle, NULL ) ;

	mallocStepDebug=3;
/*
 * Get a free buf
 */
    if ( ! pFreeList->pFirstBuf )
        pFreeList = pFreeList->pNextList ;

    if ( ! pFreeList )
    {                           //  No memory found.
    	mallocStepDebug=4;
        OsaCriticalSectionExit( Handle, NULL ) ;
        return NULL ;
    }

    for( pFree=pFreeList->pFirstBuf ; pFree ; pFree=pFree->pNextFreeBuf )
        if ( BufSize <= pFree->BufSize )
            break ;

    if ( ! pFree )
    {                           //  No memory found.
    	mallocStepDebug=5;
        OsaCriticalSectionExit( Handle, NULL ) ;
        return NULL ;
    }

//    CHECK_POOL( pPoolHeader ) ;
    OsaMemDeleteFromFreeList( pFree ) ;
//    CHECK_POOL( pPoolHeader ) ;

	mallocStepDebug=6;
/*
 * Case when the buf is large enough to be added back to list
 */
    BufSizeTail = pFree->BufSize - BufSize ;

    if ( BufSizeTail >= (SIZEOF_HDR_OF_ALLOC_BUF + SIZEOF_MIN_BUF) )
    {
        pFree->BufSize = BufSize ;
        pNewBuf = NEXT_BUF_ADRS(pFree) ;
        memset( pNewBuf, 0 , sizeof(OsaMem_BufHdr) ) ;
        SET_GUARD_IN_BUF_HDR(pNewBuf) ;
        pNewBuf->poolRef = poolRef ;
        pNewBuf->pPrevBuf = pFree ;
        pNewBuf->BufSize = BufSizeTail - SIZEOF_HDR_OF_ALLOC_BUF ;
        OsaMemAddToFreeList( pNewBuf ) ;

        NEXT_BUF_ADRS(pNewBuf)->pPrevBuf = pNewBuf ;
//        CHECK_POOL( pPoolHeader ) ;

        BufSizeTail = SIZEOF_HDR_OF_ALLOC_BUF ;     //  Used for the statistics.
    }
    else
        BufSizeTail = 0 ;                           //  Used for the statistics.

/*
 * Mark as allocated
 */
    pFree->AllocCount = 1 ;
    pFree->ReqSize = Size ;
	mallocStepDebug=7;
    if ( OsaMem_ValidityCheck == eEXT_VALIDITY_CHK )
    {
    	UINT32 *pGuard, guardLineAddr;

        //Take pDataEnd and align up (+3 & ~3)
        pGuard = (UINT32 *)
            ( ((UINT32)ALLOC_BUF_ADRS(pFree) + Size + 3) & ~3);
        *pGuard = GUARD_PATTERN ;
        guardLineAddr = (UINT32)pGuard & ~CACHE_LINE_MASK;

		CLEAN_LINE     ( guardLineAddr ) ;
		INVALIDATE_LINE( guardLineAddr ) ;

    }

/*
 * Check if the LowWaterMark is triggered.
 */
    pFreeList = &pPoolHeader->FreeList[FREE_LIST_INDEX(pFree->BufSize)] ;

    pFreeList->TotalAllocReq++ ;
    MaxAllocBuf = pFreeList->TotalAllocReq - pFreeList->TotalFreeReq ;

    if ( pFreeList->MaxAllocBuf < MaxAllocBuf )
        pFreeList->MaxAllocBuf = MaxAllocBuf ;

    if ( pPoolHeader->MaxBytesAllocated  <  (pPoolHeader->BytesAllocated += Size) )
        pPoolHeader->MaxBytesAllocated = pPoolHeader->BytesAllocated ;

    if ( pPoolHeader->MaxBytesInUse  <  (pPoolHeader->BytesInUse += (pFree->BufSize + BufSizeTail)) )
        pPoolHeader->MaxBytesInUse = pPoolHeader->BytesInUse ;

    NumberOfFreeBytes = pPoolHeader->poolSize - pPoolHeader->BytesInUse ;
	mallocStepDebug=8;
    if ( pPoolHeader->LowWaterMarkCbFunc  &&  NumberOfFreeBytes < pPoolHeader->LowWaterMark )
    {
        pPoolHeader->LowWaterMarkCbFunc( NumberOfFreeBytes ) ;
        DIAG_FILTER( OSA, OsaMem, HitWaterMark, DIAG_INFORMATION )
        diagPrintf( "Pool <%s> free bytes increased from %ld KBytes to %ld KBytes due to the LowWaterMarkCbFunc",
                    pPoolHeader->poolName, KB(NumberOfFreeBytes), KB(pPoolHeader->poolSize - pPoolHeader->BytesInUse) ) ;
		mallocStepDebug=9;
    }

    CHECK_POOL( pPoolHeader ) ;

/*
 * Exit Critical Section and return
 */
    OsaCriticalSectionExit( Handle, NULL ) ;

	pFree->callerAddress = CallerAddress;
	mallocStepDebug=10;
	
    return ALLOC_BUF_ADRS(pFree) ;
}

/***********************************************************************
 *
 * Name:        OsaMemAllocAgain()
 *
 * Description: Allocate Again the same Memory.
 *
 * Parameters:
 *  void * - starting address of the memory.
 *
 * Returns:
 *  TRUE  - Success
 *  FALSE - Fail - Memory was invalid
 *
 * Notes:
 *
 ***********************************************************************/
BOOL OsaMemAllocAgain( void *pMem )
{
    OsaMem_BufHdr
        *pBufHdr = BUF_DHR_ADRS(pMem) ;

    OsaMem_PoolHeader
        *pPoolHeader = (OsaMem_PoolHeader *)pBufHdr->poolRef ;

    OsaRefT
        Handle ;

    if ( ! VALID_PTR(pMem) )
        return FALSE ;                  //  The ASSERT is handled in the function.

    Handle = OsaCriticalSectionEnter( pPoolHeader->CriticalSectionHandle, NULL ) ;

    pBufHdr->AllocCount++ ;

    OsaCriticalSectionExit( Handle, NULL ) ;

    return TRUE ;
}

/***********************************************************************
 *
  * Name:        OsaMemCheckPools()
 *
 * Description: Check pools.
 *
 * Parameters:
 *
 * Returns:
 *
 * Notes:
 *
 ***********************************************************************/
static UINT32 OsaMem_CheckPool( OsaMem_PoolHeader *pPool )
{
    OsaMem_MemBlkHdr
        *pMemBlk ;

    OsaMem_BufHdr
        *pBuf,
        *pLastBuf ;

    for( pMemBlk=pPool->pFirstMemBlk ; pMemBlk ; pMemBlk=pMemBlk->pNextMemBlk )
    {
        pLastBuf = (OsaMem_BufHdr *)(pMemBlk->LastAddress + 1 - SIZEOF_HDR_OF_ALLOC_BUF) ;

        for( pBuf=(OsaMem_BufHdr *)pMemBlk->FirstAddress ; pBuf<pLastBuf ; pBuf=NEXT_BUF_ADRS(pBuf) )
        {
            if ( ! OsaMemValidPtr((UINT32)ALLOC_BUF_ADRS(pBuf),TRUE) )
                return (UINT32)pBuf ;
        }
    }

    return 0 ;
}

//ICAT EXPORTED FUNCTION - OSAstats,OsaMem,CheckPool
void OsaMemCheckPool( void *p, UINT32 len )
{
    OsaMem_PoolHeader
        *pPool ;

    OsaRefT
        Handle ;

    UINT32
        BrokenAddress ;

    BOOL
        LoopOnPools = TRUE ;

    if ( len >= sizeof(OsaMem_PoolHeader *) )
    {
        pPool = (OsaMem_PoolHeader *)(*(UINT32 *)p) ;

        if ( ! pPool  ||  pPool->PoolID != POOL_ID )
            pPool = OsaMem_FirstPool ;
        else
            LoopOnPools = FALSE ;       //  Work only on the requested pool.
    }
    else
        pPool = OsaMem_FirstPool ;

    do
    {
        Handle = OsaCriticalSectionEnter( pPool->CriticalSectionHandle, NULL ) ;
        BrokenAddress = OsaMem_CheckPool( pPool ) ;
        OsaCriticalSectionExit( Handle, NULL ) ;

        if ( BrokenAddress )
        {
            DIAG_FILTER( OSA, OsaMem, PoolBroken, DIAG_INFORMATION )
            diagPrintf( "Pool <%s> is broken at address 0x%lX", pPool->poolName, BrokenAddress ) ;
            return ;
        }

        DIAG_FILTER( OSA, OsaMem, PoolOK, DIAG_INFORMATION )
        diagPrintf( "Pool <%s> is OK", pPool->poolName ) ;

        pPool = pPool->pNextPool ;
    }
    while( pPool && LoopOnPools ) ;
}

/***********************************************************************
 *
  * Name:        OsaMemCreatePool()
 *
 * Description: Initialize a pool that will be handled by OSA and not by the OS.
 *              This pool always will allocate a size that is a multiply of 32 (=Cache line)
 *              and aligned 32.
 *
 * Parameters:
 *  OsaRefT                     *pOsaRef    [OT]    pointer to memory pool structure to fill
 *  OsaMemCreateParamsT         *pParams    [IN]    Input Parameters (see datatype for details).
 *
 * Returns:
 *  OS_SUCCESS          - service was completed successfully
 *  OS_INVALID_SIZE     - size not large enough.
 *  OS_INVALID_MEMORY   - illegal memory block.
 *
 * Notes:
 *
 ***********************************************************************/
OSA_STATUS OsaMemCreatePool( OsaRefT *pOsaRef, OsaMemCreateParamsT *pParams )
{
    OsaCriticalSectionCreateParamsT
        CritSecParams ;

    OSA_STATUS
        osaStatus ;

    OsaMem_PoolHeader
        *pPoolHeader ;

    OsaRefT
        Handle ;

    UINT32
        i,
        poolBase,
        poolSize = 0 ;      //  Avoid warning.

    char
        Name[MAX_NAME_LENGTH],
        *pName ;

/*
 * Check Parameters
 */
    OSA_ASSERT( pParams ) ;

    if ( ! pParams->poolBase )
    {                                   //  If no mem - alloc header from default pool.
        poolBase = (UINT32)OsaMemAlloc( NULL, POOL_HEADER_SIZE ) ;
        OSA_ASSERT( poolBase ) ;
    }

    else if ( pParams->poolSize < POOL_HEADER_SIZE )
    {
        OSA_ASSERT( FALSE ) ;
        return OS_INVALID_SIZE ;
    }

    else
    {
        poolBase = ((UINT32)pParams->poolBase + 3) & ~3 ;       //  Align 4.
        poolSize = pParams->poolSize - (poolBase - (UINT32)pParams->poolBase) ;
    }

/*
 * Set pool's header
 */
    pPoolHeader = (OsaMem_PoolHeader *)poolBase ;

    memset( pPoolHeader, 0 , POOL_HEADER_SIZE ) ;

    for( i=0 ; i<NUMBER_OF_FREE_LISTS-1 ; i++ )
        pPoolHeader->FreeList[i].pNextList = LAST_FREE_LIST(pPoolHeader) ;  //  Point to special pool.

    *pOsaRef = (OsaRefT)poolBase ;
    pPoolHeader->PoolID = POOL_ID ;

    if ( pParams->name && *pParams->name )
        pName = pParams->name ;
    else
        sprintf( pName=Name, "OsaPool@%08X", (UINT32)poolBase ) ;

//    if ( ! OsaMem_DefaultPoolRef )
//        OsaMem_DefaultPoolRef = *pOsaRef ;

    memset( (void *)&CritSecParams, 0 , sizeof(CritSecParams) ) ;
    CritSecParams.name = pName ;
    CritSecParams.bSharedForIpc = pParams->bSharedForIpc ;

    pPoolHeader->CriticalSectionHandle = OsaCriticalSectionCreate( &CritSecParams ) ;
    OSA_ASSERT( pPoolHeader->CriticalSectionHandle ) ;

    pPoolHeader->BytesInUse = pParams->poolBase ? (POOL_HEADER_SIZE + (pParams->poolSize - poolSize)) : 0 ;
    pPoolHeader->poolSize = pPoolHeader->MaxBytesInUse = pPoolHeader->BytesInUse ;
    pPoolHeader->MaxBytesAllocated = pPoolHeader->BytesAllocated = 0 ;
    pPoolHeader->LowWaterMark = pParams->LowWaterMark ;
    pPoolHeader->LowWaterMarkCbFunc = pParams->LowWaterMarkCbFunc ;

/*
 * Add memory to the pool
 */
    if ( pParams->poolBase )
    {
        osaStatus = OsaMemAddMemoryToPool( *pOsaRef, (void *)(poolBase+POOL_HEADER_SIZE), poolSize-POOL_HEADER_SIZE, NULL ) ;
        OSA_ASSERT(osaStatus == OS_SUCCESS);
    }

/*
 * Link Pools for Diag Reports
 */
    Handle = OsaCriticalSectionEnter( OsaMem_CriticalSectionHandle, NULL ) ;

    pPoolHeader->pNextPool = OsaMem_FirstPool ;
    OsaMem_FirstPool = pPoolHeader ;
    strncpy( pPoolHeader->poolName, pName, MAX_NAME_LENGTH ) ;
    pPoolHeader->poolName[MAX_NAME_LENGTH - 1] = '\0' ;

	if(OsaMem_FirstPool_Debug==NULL)
		OsaMem_FirstPool_Debug=OsaMem_FirstPool;
    OsaCriticalSectionExit( Handle, NULL ) ;

    return OS_SUCCESS ;
}

/***********************************************************************
 *
 * Name:        OsaMemDeleteFromFreeList()
 *
 * Description: Take the buffer off the free list.
 *
 * Parameters:
 *  OsaMem_BufHdr *   - pointer to the buffer.
 *
 * Notes:   This function should be called inside a critical section.
 *
 ***********************************************************************/
static void OsaMemDeleteFromFreeList( OsaMem_BufHdr *pBuf )
{
    OsaMem_PoolHeader
        *pPool = (OsaMem_PoolHeader *)pBuf->poolRef ;

    UINT32
        i = FREE_LIST_INDEX(pBuf->BufSize) ;

    OsaMem_FreeList
        *pList = &pPool->FreeList[i] ;


    OsaMem_BufHdr
        *pPrev ;

/*
 * Case when first buffer on list
 */
    if ( pList->pFirstBuf == pBuf )
    {
        pList->pFirstBuf = pBuf->pNextFreeBuf ;

        /*
         * If list became empty - point over it
         */
        if ( ! pList->pFirstBuf  &&  pList != LAST_FREE_LIST(pPool) )
        {
            while( i-- )
                if ( pPool->FreeList[i].pNextList != pList )
                    break ;
                else
                    pPool->FreeList[i].pNextList = pList->pNextList ;
        }
    }

/*
 * Case when not first buffer on list
 */
    else
    {
    	/*special use*/
		/*coverity[stray_semicolon]*/
        for( pPrev=pList->pFirstBuf ;  pPrev && pPrev->pNextFreeBuf != pBuf  ; pPrev=pPrev->pNextFreeBuf ) ;
        OSA_ASSERT( pPrev ) ;
		/*have checked the pointer*/
		/*coverity[var_deref_op]*/
        pPrev->pNextFreeBuf = pBuf->pNextFreeBuf ;
    }

    pList = &pPool->FreeList[FREE_LIST_INDEX(pBuf->BufSize)] ;
    OSA_ASSERT( pList->nFreeBuf ) ;
    pList->nFreeBuf-- ;
}

/***********************************************************************
 *
 * Name:        OsaMemFree()
 *
 * Description: Free the Memory.
 *
 * Parameters:
 *  void * - starting address of the memory.
 *
 * Notes:
 *
 ***********************************************************************/
void OsaMemFree( void *pMem )
{
    OsaMem_BufHdr
        *pBufHdr = BUF_DHR_ADRS(pMem),
        *pNeighbour ;

    OsaMem_PoolHeader
        *pPoolHeader = (OsaMem_PoolHeader *)pBufHdr->poolRef ;

    OsaMem_FreeList
        *pOrigList = &pPoolHeader->FreeList[FREE_LIST_INDEX(pBufHdr->BufSize)] ;

    OsaRefT
        Handle ;

    UINT32
        BytesAddedToPool ;

/*
 * Enter Critical Section
 */
 	addr_debug = (UINT32)pMem;
    if ( ! VALID_PTR(pMem) )
        return ;                        //  The ASSERT is handled in the function.

    Handle = OsaCriticalSectionEnter( pPoolHeader->CriticalSectionHandle, NULL ) ;

/*
 * Case when more than one user on this memory.
 */
    if ( --pBufHdr->AllocCount )
    {
        OsaCriticalSectionExit( Handle, NULL ) ;
        return ;
    }

    pOrigList->TotalFreeReq++ ;

    pPoolHeader->BytesAllocated -= pBufHdr->ReqSize ;

    pBufHdr->ReqSize = 0 ;

    BytesAddedToPool = pBufHdr->BufSize ;

/*
 * Case when prev buffer is not free
 */
    pNeighbour = pBufHdr->pPrevBuf ;

//    CHECK_POOL( pPoolHeader ) ;

    if ( ! pNeighbour  ||  pNeighbour->AllocCount )
    {
        INVALIDATE_MEMORY( pMem, pBufHdr->BufSize ) ;

        pNeighbour = NEXT_BUF_ADRS(pBufHdr) ;
    }

/*
 * When prev buffer is free - take it off list and combine them together
 */
    else
    {
        OsaMemDeleteFromFreeList( pNeighbour ) ;

        pBufHdr->BufSize += SIZEOF_HDR_OF_ALLOC_BUF ;
        pNeighbour->BufSize += pBufHdr->BufSize ;
        INVALIDATE_MEMORY( pBufHdr, pBufHdr->BufSize ) ;
        pBufHdr = pNeighbour ;
        pNeighbour = NEXT_BUF_ADRS(pBufHdr) ;
        pNeighbour->pPrevBuf = pBufHdr ;
        BytesAddedToPool += SIZEOF_HDR_OF_ALLOC_BUF ;
//        CHECK_POOL( pPoolHeader ) ;
    }

/*
 * When next buffer is free - take it off list and combine them together
 */
    if ( pNeighbour  &&  ! pNeighbour->AllocCount )
    {
        OsaMemDeleteFromFreeList( pNeighbour ) ;

        pBufHdr->BufSize += pNeighbour->BufSize + SIZEOF_HDR_OF_ALLOC_BUF ;
        INVALIDATE_MEMORY( pNeighbour, SIZEOF_HDR_OF_ALLOC_BUF ) ;
        pNeighbour = NEXT_BUF_ADRS(pBufHdr) ;
        pNeighbour->pPrevBuf = pBufHdr ;
        BytesAddedToPool += SIZEOF_HDR_OF_ALLOC_BUF ;
//        CHECK_POOL( pPoolHeader ) ;
    }

/*
 * Add the buf to free list
 */
    OsaMemAddToFreeList( pBufHdr ) ;

    pPoolHeader->BytesInUse -= BytesAddedToPool ;

    CHECK_POOL( pPoolHeader ) ;
    OsaCriticalSectionExit( Handle, NULL ) ;
}

/***********************************************************************
 *
 * Name:        OsaMemGetAllocSize()
 *
 * Description: Returns the number of bytes that are actualay allocated.
 *
 * Parameters:
 *
 * Notes:
 *
 ***********************************************************************/
UINT32 OsaMemGetAllocSize( void *pMem )
{
    if ( ! VALID_PTR(pMem) )
        return 0 ;

    return BUF_DHR_ADRS(pMem)->BufSize ;
}

/***********************************************************************
 *
 * Name:        OsaMemGetDefaultPoolRef()
 *
 * Description: Get the pool reference of the default pool
 *
 * Parameters:
 *
 * Notes:
 *
 ***********************************************************************/
OsaRefT OsaMemGetDefaultPoolRef( void )
{
    return OsaMem_DefaultPoolRef ;
}

/***********************************************************************
 *
 * Name:        OsaMemGetPoolRef()
 *
 * Description: Get the pool reference according to name or memory addresss
 *
 * Parameters:
 *  char * - Pool Name
 *  void * - A memory address.
 *
 * Notes:
 *
 ***********************************************************************/
OsaRefT OsaMemGetPoolRef( char *poolName, void *pMem, void *pForFutureUse )
{
    OsaMem_MemBlkHdr
        *pMemBlk ;

    OsaMem_PoolHeader
        *pPool ;

    for( pPool=OsaMem_FirstPool ; pPool ; pPool=pPool->pNextPool )
    {
        if ( poolName  &&  ! strcmp(pPool->poolName,poolName) )
            return (OsaRefT)pPool ;

        for( pMemBlk=pPool->pFirstMemBlk ; pMemBlk ; pMemBlk=pMemBlk->pNextMemBlk )
            if ( (UINT32)pMem >= pMemBlk->FirstAddress  &&  (UINT32)pMem <= pMemBlk->LastAddress )
                return (OsaRefT)pPool ;
    }

    return NULL ;
}

/***********************************************************************
 *
 * Name:        OsaMemGetUserParam()
 *
 * Description: Returns the user's parameter from the internal database.
 *
 * Parameters:
 *
 * Notes:
 *
 ***********************************************************************/
UINT32 OsaMemGetUserParam( void *pMem )
{
    if ( ! VALID_PTR(pMem) )
        return 0 ;

    return BUF_DHR_ADRS(pMem)->UserParam ;
}

/***********************************************************************
 *
  * Name:        OsaMem_InitPools()
 *
 * Description: Initialize this module.
 *
 * Parameters:
 *
 * Returns:
 *  OS_SUCCESS
 *  OS_FAIL
 *
 * Notes:
 *
 ***********************************************************************/
OSA_STATUS OsaMem_InitPools( void )
{
    OsaCriticalSectionCreateParamsT
        Params ;

    if ( SIZEOF_HDR_OF_ALLOC_BUF != SIZEOF_CACHE_LINE )
        OSA_ASSERT( FALSE ) ;   //  BUF_HDR_GUARD Has a wrong value

    memset( (void *)&Params, 0 , sizeof(Params) ) ;
    Params.name = "OsaMemPoolBase" ;

    OsaMem_CriticalSectionHandle = OsaCriticalSectionCreate( &Params ) ;

    if ( ! OsaMem_CriticalSectionHandle )
    {
        OSA_ASSERT( FALSE ) ;
        return OS_FAIL ;
    }

    OsaMem_DefaultPoolRef = NULL ;
    OsaMem_FirstPool = NULL ;
#if defined (_QT_)
    OsaMem_ValidityCheck = eMIN_VALIDITY_CHK ;
#else
    OsaMem_ValidityCheck = eEXT_VALIDITY_CHK ;
#endif

    return OS_SUCCESS ;
}

/***********************************************************************
 *
  * Name:        OsaMemPoolsStatus()
 *
 * Description: Display pools status.
 *
 * Parameters:
 *
 * Returns:
 *  OS_SUCCESS
 *  OS_FAIL
 *
 * Notes:
 *
 ***********************************************************************/
//ICAT EXPORTED FUNCTION - OSAstats,OsaMem,PoolsStatus
void OsaMemPoolsStatus( void *p, UINT32 len )
{
    OsaMem_PoolHeader
        *pPool ;

    OsaMem_FreeList
        *pList ;

    OsaMem_MemBlkHdr
        *pMemBlk ;

    UINT32
        i ;

    BOOL
        LoopOnPools = TRUE ;

    if ( len >= sizeof(OsaMem_PoolHeader *) )
    {
        pPool = (OsaMem_PoolHeader *)(*(UINT32 *)p) ;

        if ( ! pPool  ||  pPool->PoolID != POOL_ID )
            pPool = OsaMem_FirstPool ;
        else
            LoopOnPools = FALSE ;       //  Work only on the requested pool.
    }
    else
        pPool = OsaMem_FirstPool ;

    do
    {
        DIAG_FILTER( OSA, OsaMem, PoolName, DIAG_INFORMATION )
        diagPrintf( "Pool <%s> @ 0x%lX", pPool->poolName, (UINT32)pPool ) ;

        DIAG_FILTER( OSA, OsaMem, KBytes, DIAG_INFORMATION )
        diagPrintf( "Size=%ld, InUsed-Peak=%ld, InUse=%ld, Allocated-Peak=%ld, Allocatd=%ld",
                        KB(pPool->poolSize), KB(pPool->MaxBytesInUse), KB(pPool->BytesInUse), KB(pPool->MaxBytesAllocated), KB(pPool->BytesAllocated) ) ;

        for( i=0, pMemBlk=pPool->pFirstMemBlk ; pMemBlk ; pMemBlk=pMemBlk->pNextMemBlk )
        {
            DIAG_FILTER( OSA, OsaMem, MemBlk, DIAG_INFORMATION )
            diagPrintf( "%ld: From 0x%lX To 0x%lX", ++i, pMemBlk->FirstAddress, pMemBlk->LastAddress ) ;
        }

        for( pList=pPool->FreeList ; pList<LAST_FREE_LIST(pPool) ; pList++  )
            if ( pList->maxFreeBuf || pList->TotalAllocReq )
            {
                i = ((UINT32)pList - (UINT32)pPool->FreeList) / sizeof(OsaMem_FreeList) ;
                DIAG_FILTER( OSA, OsaMem, FreeList, DIAG_INFORMATION )
                diagPrintf( "%ld: Size=%ld, AllocReq=%ld, FreeReq=%ld, MaxAlloc=%ld, maxFree=%ld, nFree=%ld",
                            i, (i+1)*SIZEOF_MIN_BUF, pList->TotalAllocReq, pList->TotalFreeReq,
                            pList->MaxAllocBuf, pList->maxFreeBuf, pList->nFreeBuf ) ;
            }

        pPool = pPool->pNextPool ;
    }
    while( pPool && LoopOnPools ) ;
}

/***********************************************************************
 *
 * Name:        OsaMemResizeAlloc()
 *
 * Description: If NewSize > ReqSize - free tail (if possible)
 *              Else if NewSize > BufSize - do nothing (return FALSE)
 *              Else set NewSize in ReqSize and handle the memory Guard.
 *
 * Parameters:
 *  void * - starting address of the memory.
 *
 * Returns:
 *  TRUE  - Success
 *  FALSE - Fail
 *
 * Notes:
 *
 ***********************************************************************/
BOOL OsaMemResizeAlloc( void *pMem, UINT32 NewSize )
{
    OsaMem_BufHdr
        *pBuf = BUF_DHR_ADRS(pMem),
        *pNewBuf ;

    OsaMem_PoolHeader
        *pPoolHeader = (OsaMem_PoolHeader *)pBuf->poolRef ;

    OsaRefT
        Handle ;

    UINT32
        TailSize ;

    if ( ! VALID_PTR(pMem) )
        return FALSE ;                  //  The ASSERT is handled in the function.

    if ( NewSize > pBuf->BufSize )
        return FALSE ;                  //  Can't give more memory.

    Handle = OsaCriticalSectionEnter( pPoolHeader->CriticalSectionHandle, NULL ) ;

    TailSize = pBuf->BufSize - NewSize ;

    if ( TailSize < (SIZEOF_HDR_OF_ALLOC_BUF + SIZEOF_MIN_BUF) )
        return FALSE ;

    pBuf->BufSize = NewSize ;
    pNewBuf = NEXT_BUF_ADRS(pBuf) ;
    memset( pNewBuf, 0 , sizeof(OsaMem_BufHdr) ) ;
    SET_GUARD_IN_BUF_HDR(pNewBuf) ;
    pNewBuf->poolRef = pBuf->poolRef ;
    pNewBuf->pPrevBuf = pBuf ;
    TailSize -= SIZEOF_HDR_OF_ALLOC_BUF ;
    pNewBuf->BufSize = TailSize ;
    OsaMemAddToFreeList( pNewBuf ) ;

    NEXT_BUF_ADRS(pNewBuf)->pPrevBuf = pNewBuf ;

    if ( pPoolHeader->MaxBytesAllocated  <  (pPoolHeader->BytesAllocated += (pBuf->ReqSize - NewSize)) )
        pPoolHeader->MaxBytesAllocated = pPoolHeader->BytesAllocated ;

    if ( pPoolHeader->MaxBytesInUse  <  (pPoolHeader->BytesInUse -= TailSize) )
        pPoolHeader->MaxBytesInUse = pPoolHeader->BytesInUse ;

    pBuf->ReqSize = NewSize ;

    OsaCriticalSectionExit( Handle, NULL ) ;

    return TRUE ;
}

/***********************************************************************
 *
 * Name:        OsaMemSetDefaultPool()
 *
 * Description: Decide on the default pool.
 *
 * Parameters:
 *  OsaRefT       poolRef     - memory pool reference
 *
 * Notes:
 *
 ***********************************************************************/
void OsaMemSetDefaultPool( OsaRefT poolRef )
{
    OsaMem_DefaultPoolRef = poolRef ;
}

/***********************************************************************
 *
 * Name:        OsaMemSetUserParam()
 *
 * Description: Enables the user to save a 32 bit parameter in the internal database.
 *
 * Parameters:
 *  void *  -   Starting address of the allocated memory.
 *  UINT32  -   Value to save.
 *
 * Returns:
 *  TRUE  - Success
 *  FALSE - Fail
 *
 * Notes:
 *
 ***********************************************************************/
OSA_STATUS OsaMemSetUserParam( void *pMem, UINT32 UserParam )
{
    if ( ! VALID_PTR(pMem) )
        return OS_INVALID_MEMORY ;          //  The ASSERT is handled in the function.

    BUF_DHR_ADRS(pMem)->UserParam = UserParam ;

    return OS_SUCCESS ;
}

/***********************************************************************
 *
 * Name:        OsaMemSetUserParamsFast()
 *
 * Description: Setting the caller address and User's general parameter in the block header
 *
 * Parameters:
 *  void *  -   Starting address of the allocated memory.
 *  UINT32 UserParam -   Value to save in user param.
 *  UINT32 CallerAddress - Value to save in caller address
 *
 ***********************************************************************/
void OsaMemSetUserParamsFast( void *pMem, UINT32 UserParam, UINT32 CallerAddress  )
{
     BUF_DHR_ADRS(pMem)->UserParam = UserParam ;
	 BUF_DHR_ADRS(pMem)->callerAddress = CallerAddress ;
}


/***********************************************************************
 *
 * Name:        OsaMemValidPtr()
 *
 * Description: Checks if the allocated memory is a valid memory buffer.
 *
 * Parameters:
 *  UINT32      FirstAddress    - starting address of memory.
 *
 * Returns:
 *  TRUE  - Valid Memory
 *  FALSE - Invalid Memory
 *
 * Notes:
 *
 ***********************************************************************/
static BOOL OsaMemValidPtr( UINT32 FirstAddress, BOOL PoolCheck )
{
    OsaMem_BufHdr
        *pBufHdr ;

    OsaMem_MemBlkHdr
        *pMemBlk ;

    OsaMem_PoolHeader
        *pPool ;

    UINT32
        LastAddress,
        *pGuard ;

/*
 * Check Address
 */
    if ( ! FirstAddress )
    {                                   //  Address is NULL.
        OSA_ASSERT( FALSE ) ;
        return FALSE ;
    }

    if ( FirstAddress & CACHE_LINE_MASK )
    {                                   //  Address is not aligned.
        OSA_ASSERT( FALSE ) ;
        return FALSE ;
    }

/*
 * Check Buf Header
 */
    pBufHdr = BUF_DHR_ADRS(FirstAddress) ;

    {
#if 1   //  Faster.
        if ( pBufHdr->Guard != GUARD_PATTERN )
#else
        UINT32
            i ;

        for( i=0 ; i<BUF_HDR_GUARD ; i++ )
            if ( pBufHdr->Guard[i] != GUARD_PATTERN )
#endif
            {                               //  No header guard.
                OSA_ASSERT( FALSE ) ;
                return FALSE ;
            }
    }

    if ( PoolCheck )
    {
        if ( (pBufHdr->AllocCount  &&  ! pBufHdr->ReqSize)  ||  (! pBufHdr->AllocCount  &&  pBufHdr->ReqSize) )
        {
            OSA_ASSERT( FALSE ) ;
            return FALSE ;
        }
    }

    else if ( ! pBufHdr->AllocCount  ||  ! pBufHdr->ReqSize )
    {
        OSA_ASSERT( FALSE ) ;
        return FALSE ;
    }

    if ( ((OsaMem_PoolHeader *)(pBufHdr->poolRef))->PoolID != POOL_ID )
    {
        OSA_ASSERT( FALSE ) ;
        return FALSE ;
    }

    LastAddress = (UINT32)NEXT_BUF_ADRS(pBufHdr) ;

    if ( OsaMem_ValidityCheck == eEXT_VALIDITY_CHK )
    {
#if (defined FLAVOR_APP)
        if ( ! PoolCheck )              //  Avoid ASSERT on APP side when checking a COM pool.
#endif
        {
            for( pPool=OsaMem_FirstPool ; pPool ; pPool=pPool->pNextPool )
                if ( (OsaRefT *)pPool == pBufHdr->poolRef )
                    break ;

            if ( ! pPool )
            {                               //  Illegal poolRef.
                OSA_ASSERT( FALSE ) ;
                return FALSE ;
            }

            for( pMemBlk=pPool->pFirstMemBlk ; pMemBlk ; pMemBlk=pMemBlk->pNextMemBlk )
                if ( FirstAddress >= pMemBlk->FirstAddress  &&  LastAddress <= pMemBlk->LastAddress )
                    break ;

            if ( ! pMemBlk )
            {                               //  Invalid buf size.
                OSA_ASSERT( FALSE ) ;
                return FALSE ;
            }
        }

        if ( pBufHdr != ((OsaMem_BufHdr *)LastAddress)->pPrevBuf )
        {                               //  Invalid buf size.
            OSA_ASSERT( FALSE ) ;
            return FALSE ;
        }

/*
 * Check memory guard
 */
        if ( pBufHdr->AllocCount )
        {
        	 //Take pDataEnd and align up (+3 & ~3)
            pGuard = (UINT32 *)
                ((FirstAddress + pBufHdr->ReqSize + 3) & ~3) ;

            if ( *pGuard != GUARD_PATTERN )
            {   //  No memory guard found
                OSA_ASSERT( FALSE ) ;
                return FALSE ;
            }
			
        }
    }

    return TRUE ;
}


//ICAT EXPORTED FUNCTION - OSAstats,OsaMem,getOsaMemPoolsUsage
UINT32 getOsaMemPoolsUsage(OSPoolRef poolRef, BOOL logEnale)
{
    OsaMem_PoolHeader
        *pPool ;

    
    pPool = (OsaMem_PoolHeader *)(poolRef) ;

    if ( ! pPool  ||  pPool->PoolID != POOL_ID )
    {
    	return 0;
    }
     
	if(logEnale == TRUE)
	{
		DIAG_FILTER( OSA, OsaMem, PoolName, DIAG_INFORMATION )
		diagPrintf( "Pool <%s> @ 0x%lX", pPool->poolName, (UINT32)pPool ) ;

		DIAG_FILTER( OSA, OsaMem, KBytes, DIAG_INFORMATION )
		diagPrintf( "Size=0x%lx, InUsed-Peak=0x%lx, InUse=0x%lx, Allocated-Peak=0x%lx, Allocatd=0x%lx",
					pPool->poolSize, pPool->MaxBytesInUse, pPool->BytesInUse, pPool->MaxBytesAllocated, pPool->BytesAllocated) ;
	}
	return  pPool->BytesInUse;
	
}


OSA_STATUS OsaListAllCreatedMemBytesPoolsStatus(void)
{
	UINT16 i;
	OsaMem_PoolHeader  *pPool ;

    OsaMem_MemBlkHdr *pMemBlk ;

	pPool = OsaMem_FirstPool ;

	
	while( pPool)
	{
		DIAG_FILTER( OSA, OSA_DUMP, OSAListAllCreatedBytesPoolStatus_Name, DIAG_INFORMATION )
		diagPrintf( "Pool <%s> @ 0x%lX", pPool->poolName, (UINT32)pPool ) ;
		
		uart_printf( "Pool <%s> @ 0x%lX\r\n", pPool->poolName, (UINT32)pPool ) ;

		DIAG_FILTER( OSA, OSA_DUMP, OSAListAllCreatedBytesPoolStatus_Usage, DIAG_INFORMATION )
		diagPrintf( "Size=0x%lx, InUsed-Peak=0x%lx, InUse=0x%lx, Allocated-Peak=0x%lx, Allocatd=0x%lx",
						pPool->poolSize, pPool->MaxBytesInUse, pPool->BytesInUse, pPool->MaxBytesAllocated, pPool->BytesAllocated ) ;


		uart_printf( "Size=0x%lx, InUsed-Peak=0x%lx, InUse=0x%lx, Allocated-Peak=0x%lx, Allocatd=0x%lx\r\n",
								pPool->poolSize, pPool->MaxBytesInUse, pPool->BytesInUse, pPool->MaxBytesAllocated, pPool->BytesAllocated ) ;

		for( i=0, pMemBlk=pPool->pFirstMemBlk ; pMemBlk ; pMemBlk=pMemBlk->pNextMemBlk,i++ )
		{
			DIAG_FILTER( OSA, OSA_DUMP, OSAListAllCreatedBytesPoolStatus_Mem, DIAG_INFORMATION )
			diagPrintf( "%ld: From 0x%lX To 0x%lX", i, pMemBlk->FirstAddress, pMemBlk->LastAddress ) ;

			uart_printf( "%ld: From 0x%lX To 0x%lX\r\n", i, pMemBlk->FirstAddress, pMemBlk->LastAddress ) ;
		}

		pPool = pPool->pNextPool ;
	
	}

	return OS_SUCCESS;
}

